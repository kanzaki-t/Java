- 多线程
    程序（program）：为完成特定任务，用某种语言编写的一组指令的集合。即指一段静态代码，静态对象。
    进程（process）：程序的一次执行过程，或是正在内存中运行的应用程序。是动态的。
    线程（thread）：进程可以进一步细化为线程，是程序内部的一条执行路径。一个进程中至少有一个线程。

    并行（parallel）：指两个或多个事件在同一时刻发生，比如多个人同时做不同的事。
    并发（concurrency）：指两个或多个事件在同一个时间段内发生。

    线程的创建方式一
        继承Thread类
            1.创建一个继承于Thread类的子类
            2.重写Thread类的run()方法 ----> 此线程要执行的操作，声明在此方法体中
            3.创建当前Thread子类的对象
            4.通过对象调用start()

    线程的创建方式二
        实现Runnable接口
            1.创建一个实现Runnable接口的类
            2.实现接口中的run()方法 ----> 此线程要执行的操作，声明在此方法体中
            3.创建当前实现类的对象
            4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的实例
            5.Thread类的实例调用start()

    对比两种方式：
        共同点：
            1.启动线程，使用的都是Thread类中定义的start()方法
            2.创建的线程对象，都是Thread类或其子类的实例
        不同点：一个事类的继承，一个是接口的实现
        建议：使用Runnable
            原因：
                1.避免了类的单继承的局限性
                2.更适合处理有共享数据的问题


    线程的常用结构
        1.线程中的构造器
            public Thread_01():分配一个新的线程对象
            public Thread_01(String name):分配一个指定名字的新的线程对象
            public Thread_01(Runnable_03 target):指定创建线程的目标对象，他实现了Runnable接口中的run方法
            public Thread_01(Runnable_03 target,String name):分配一个带有指定目标新的线程对象并指定名字

        2.线程中常用的方法
            start():启动线程，调用线程的run()
            run():声明线程要执行的操作
            currentThread():获取当前执行代码对应的线程
            getName():获取当前执行代码对应的线程的名字
            setName():设置线程的名字
            sleep(毫秒值):静态方法，调用时，可以使得当前线程睡眠指定的毫秒数
            yield():一旦执行此方法，就释放cpu的执行权
            join():在线程A中，通过线程B调用join(),意味着线程A进入阻塞状态，直到线程B执行结束，线程A才结束阻塞状态，重新执行
            isAlive():判断线程是否还存活

        3.线程的优先级
            getPriority():获取当前线程的优先级
            setPriority():设置当前线程的优先级 // setPriority(Thread_01.MAX_PRIORITY)

            MAX_PRIORITY = 10
            MIN_PRIORITY = 1
            NORM_PRIORITY = 5

        4.生命周期


    线程的安全问题与线程的同步机制
        1.多线程卖票，出现的问题：
            出现了重票和错票
        2.什么原因：
            线程1操作ticket的过程中，尚未结束的情况下，其他线程也参与进来，对ticket进行操作
        3.如何解决：
            必须保证一个线程1在操作ticket的过程中，其他线程必须等待，直到线程1操作ticket结束以后，
            其他线程才可以进来继续操作ticket
        4.java是如何解决线程的安全问题的：
            使用线程的同步机制
                1.同步代码块
                    synchronized(同步监视器){
                        //需要被同步的代码
                    }

                    需要被同步的代码：
                        操作共享数据的代码
                        共享数据：多个线程都需要操作的数据，如ticket
                        需要被同步的代码，在被synchronized包裹以后，就使得一个线程在操作这些代码的过程中，其他线程必须等待。

                    同步监视器：
                        俗称锁，哪个线程获取了锁，哪个线程就能执行需要被同步的代码
                        可以使用任何一个类的对象充当同步监视器，但是，多个线程必须共用同一个同步监视器,必须具有唯一性

                    注意：
                        在实现Runnable接口的方式中，同步监视器可以考虑使用：this
                        在继承Thread类的方式中，同步监视器要慎用this，可以考虑使用：当前类名.class
                2.同步方法
                    如果操作共享数据的代码完整的声明在了一个方法中，那么我们就可以将此方法声明为同步方法即可。
                    非静态的同步方法，默认同步监视器是this
                    静态的同步方法，默认同步监视器是当前类

        5.synchronized
            好处：解决了线程的安全问题
            坏处：在操作共享数据时，多线程其实是串行执行的（单线程），意味着性能低

    死锁deadLock
        不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁

        诱发死锁的原因
            互斥条件
            占用且等待
            不可抢夺
            循环等待

        解决死锁
            互斥条件基本上无法破坏
            可以考虑一次性申请所有所需的资源，这样就不用等待了
            占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源
            可以将资源改为线性顺序，申请资源时，先申请序号较小的，这样避免循环等待问题


    Lock
        1. 创建Lock的实例，需要确保多个线程共用同一个Lock实例，需要声明为static final
        2. 锁定对共享资源的调用
        3. 释放对共享数据的锁定

    synchronized和Lock
        synchronized：不管是同步代码块还是同步方法，都需要在结束一对{}之后，释放对同步监视器的调用
        Lock：是通过两个方法控制需要被同步的代码，更灵活一些
            作为接口，提供了多种实现类，适合更多更复杂的场景，效率更高

    线程之间的通信机制
        当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行，
        那么多线程之间需要一些通信机制，可以协调他们的工作，以此实现多线程共同操作一份数据。

        涉及的方法：
            wait()
                线程一旦执行此方法，就进入等待状态，会释放对同步监视器的调用
            notify()
                一旦执行此方法，就会唤醒被wait()的线程中优先级最高的那一个线程
                如果被wait()的多个线程的优先级相同，则随机唤醒一个。
            notifyAll()
                 一旦执行此方法，就会唤醒所有被wait()的线程

        注意点：
            此3个方法的使用，必须实在同步代码块或同步方法中。
            Lock需要配合Condition实现线程间的通信
            此3个方法的调用者，必须是同步监视器，否则，会报错IllegalMonitorStateException

        wait() 和 sleep() 的区别：
            相同点：一旦执行，当前线程都会进入阻塞状态

            不同点：
                声明的位置：
                    wait()：声明在同步监视器类中
                    sleep():声明在Thread类中，静态的

                使用的场景：
                    wait()：只能使用在同步代码块或同步方法中
                    sleep():可以在任何需要使用的场景

                使用在同步代码块或同步方法中：
                    wait()：一旦执行，会释放同步监视器
                    sleep():一旦执行，不会释放同步监视器

                结束阻塞的方式：
                    wait()：到达指定时间自动结束阻塞
                            通过notify唤醒结束阻塞
                    sleep():到达指定时间自动结束阻塞

    线程的创建方式三
        实现Callable jdk5.0
            可以有返回值
            可以用throws的方式处理异常
            使用了泛型参数，可以指明具体的call()的返回值类型

            如果在主线程中需要获取分线程的返回值，则此时的主线程是阻塞状态的

    线程的创建方式四
        线程池（开发中常使用）
            提高了程序执行的效率，因为线程已经提前创建好了
            提高了资源的复用率，因为执行完的线程并未销毁，而是可以继续执行其他的任务
            可以设置相关的参数，对线程池中的线程的使用进行管理